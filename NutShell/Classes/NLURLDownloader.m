/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id: NLURLDownloader.m 248 2010-08-25 14:12:28Z  $ */

#import "NLURLDownloader.h"
#import "NLEventDispatcher.h"

@interface NLURLDownloader( Private ) < NSURLDownloadDelegate >

- ( void )updateSpeed: ( NSTimer * )timerObject;

@end

@implementation NLURLDownloader

@synthesize downloading;
@synthesize downloaded;
@synthesize allowOverwrite;
@synthesize bytesTotal;
@synthesize bytesReceived;
@synthesize bytesPerSecond;
@synthesize percentComplete;
@synthesize secondsRemaining;
@synthesize url;
@synthesize downloadDirectory;
@synthesize downloadLocation;

+ ( id )downloaderFromURL: ( NSURL * )urlObject
{
    id downloader = [ [ self alloc ] initWithURL: urlObject ];
    
    return [ downloader autorelease ];
}

+ ( id )downloaderFromString: ( NSString * )str
{
    id downloader = [ [ self alloc ] initWithString: str ];
    
    return [ downloader autorelease ];
}

- ( id )initWithURL: ( NSURL * )urlObject
{
    if( ( self = [ self init ] ) )
    {
        url      = [ urlObject copy ];
        request  = [ [ NSURLRequest requestWithURL: url cachePolicy: NSURLRequestUseProtocolCachePolicy timeoutInterval: 60.0 ] retain ];
    }
    
    return self;
}

- ( id )initWithString: ( NSString * )str
{
    if( ( self = [ self init ] ) )
    {
        url      = [ [ NSURL URLWithString: str ] retain ];
        request  = [ [ NSURLRequest requestWithURL: url cachePolicy: NSURLRequestUseProtocolCachePolicy timeoutInterval: 60.0 ] retain ];
    }
    
    return self;
}

- ( void )dealloc
{
    [ url release ];
    [ downloadDirectory release ];
    [ downloadLocation release ];
    [ download release ];
    [ request release ];
    [ response release ];
    [ super dealloc ];
}

- ( BOOL )start
{
    if( downloading )
    {
        return NO;
    }
    
    if( !downloadDirectory )
    {
        self.downloadDirectory = [ NSHomeDirectory() stringByAppendingPathComponent: @"Downloads" ];
    }
    
    download = [ [ NSURLDownload alloc ] initWithRequest: request delegate: self ];
    
    if( !download )
    {
        return NO;
    }
    
    timer             = [ NSTimer scheduledTimerWithTimeInterval: 1 target: self selector: @selector( updateSpeed: ) userInfo: nil repeats: YES ];
    downloading       = YES;
    downloaded        = NO;
    bytesReceived     = 0;
    lastBytesReceived = 0;
    
    [ self dispatchEvent: @"DownloadStarted" ];
    
    return YES;
}

- ( void )cancel
{
    if( downloading )
    {
        [ download cancel ];
        [ timer invalidate ];
        
        [ self dispatchEvent: @"DownloadCancelled" ];
    }
}

- ( void )downloadDidFinish: ( NSURLDownload * )downloadObject 
{
    ( void )downloadObject;
    
    [ timer invalidate ];
    
    downloading = NO;
    downloaded  = YES;
    
    [ self dispatchEvent: @"DownloadComplete" ];
}

- ( void )download: ( NSURLDownload * )downloadObject didFailWithError: ( NSError * )error 
{
    ( void )downloadObject;
    
    [ timer invalidate ];
    
    downloading = NO;
    
    [ self dispatchEvent: @"DownloadError" target: error ];
}

- ( void )download: ( NSURLDownload * )downloadObject decideDestinationWithSuggestedFilename: ( NSString * )filename 
{
    [ downloadLocation release ];
    
    downloadLocation = [ [ downloadDirectory stringByAppendingPathComponent: filename ] retain ];
    
    [ downloadObject setDestination: downloadLocation allowOverwrite: allowOverwrite ];
}

- ( void )download: ( NSURLDownload * )downloadObject didCreateDestination: ( NSString * )path
{
    ( void )downloadObject;
    
    [ downloadLocation release ];
    
    downloadLocation = [ path copy ];
}

- ( void )download: ( NSURLDownload * )downloadObject didReceiveResponse: ( NSURLResponse * )responseObject
{
    ( void )downloadObject;
    
    [ responseObject retain];
    [ response release];
    
    bytesReceived = 0;
    response      = responseObject;
    bytesTotal    = [ responseObject expectedContentLength ];
    
    [ self dispatchEvent: @"ResponseReceived" ];
}

- ( void )download: ( NSURLDownload * )downloadObject didReceiveDataOfLength: ( NSUInteger )length 
{
    ( void )downloadObject;
    
    bytesReceived += length;
    
    if( bytesTotal != NSURLResponseUnknownLength )
    {
        percentComplete = ( bytesReceived / ( double )bytesTotal ) * 100.0;
    }
    
    [ self dispatchEvent: @"DataReceived" ];
}

- ( void )updateSpeed: ( NSTimer * )timerObject
{
    ( void )timerObject;
    
    bytesPerSecond    = bytesReceived - lastBytesReceived;
    lastBytesReceived = bytesReceived;
    secondsRemaining  = ( bytesTotal - bytesReceived ) / bytesPerSecond;
    
    [ self dispatchEvent: @"DownloadSpeedUpdated" ];
}

@end
